# 알고리즘 응용

## 복잡도 분석

### 알고리즘의 효율

**알고리즘의 효율은 공간적 효율성과 시간적 효율성이 있다**

- **공간적 효율성**

  - 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다

- **시간적 효율성**

  - 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.

  **효율성을 뒤집어 말하면 복잡도(Complexity)이다. 복잡도가 높을수록 효율성은 저하된다.**



- **시간복잡도(Time Complexity)**

  시간 복잡도는 하드웨어(부동소수 처리 프로세서 유뮤, 나눗셈 가속기능 유무, 입출력 장비의 성능, 공유 등등), 소프트웨어(프로그램 언어, 운영체제, 컴파일러)의 환경에 따라 처리시간이 달라지므로 분석하기 어렵다.

  그러므로 일반적으로 시간 복잡도를 측정할 때는 알고리즘이 얼마나 많은 연산을 하는지를 기준으로 복잡도를 정하게 된다. 이렇게 정한 복잡도를 단순한 함수 형태로 표기하기 위해 점근적 표기(Asymptotic Notation)을 사용하는데, 이 표기법들에는

  - O(Big-Oh) 표기법 : 복잡도의 점근적 상한을 나타냄, 
  - $\Omega$ (Big-Omega) 표기법 : 복잡도의 점근적 하한을 나타냄. = 최소 이만한 시간은 걸린다
  - $\Theta$(Big-Theta) 표기법 : O표기와 $\Omega$ 표기가 동일할 때, 

  등이 있다.

  그중에서도 __O(Big-oh)__ 표기법을 많이 쓰게된다.

  - O(1) : 상수시간 (Constant time)
  - O(logn) 로그(대수) 시간 (Logarithmic time)
  - O(n) 선형 시간 (Linear time)
  - O(nlogn) 로그 선형 시간(Log-linear time)
  - O(n^2) 제곱 시간 (Quadratic time)
  - O(n^3) 세제곱 시간 (Cubic time)
  - O(2^n) 지수 시간 (Exponential time)

  효율적인 알고리즘이 슈퍼컴퓨터보다 더 큰 가치가 있음.

## 완전탐색 & 그리디(Greedy)

### 반복(Iteration) & 재귀(Recursion)

- 반복 
  - 수행하는 작업이 완료될 때 까지 반복
  - 반복은 초기화, 조건검사, 실행, 업데이트로 이루어진다. 업데이트가 되지 않거나 조건이 잘못되면 무한반복이 일어나므로 조심해야 한다.
- 재귀
  - 문제의  최종해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용 (ex. 점화식)
  - 문제를 재귀적으로 정의하면 두 부분으로 나누어 생각할 수 있다.
    - 하나 또는 그 이상의 기본 경우(basis case or rule)
      - 
    - 하나 또는 그 이상의 유도된 경우(inductive case or rule)

# Tree

- 트리에 대해 알아야 할 것들

  - 표현

    - 자료구조에 따라 어떤 트리가 적당한지 알고 있어야 합니다.

  - 순회

    - 완전탐색의 방법
      - DFS
      - BFS
      - pre-order
      - post-order
      - in-order

  - 트리의 종류

    - 이진트리(이원트리, Binary Tree)

      모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리

      각 노드가 자식 노드를 최대 2개 까지만 가질 수 있는 트리입니다.

      이진트리의 자식노드는 왼쪽자식 노드(left child node)와 오른쪽 자식 노드(right child node)로 구분하여 말합니다.

      - 특성
        
        - 레벨 i인 이진 트리의 노드의 최대 개수는 2 ^ i 개이고 최소 개수는 i + 1 입니다.
        
        - 완전 이진트리에서 노드의 번호를 1부터 매겼을 때, 노드 번호가 N이고 부모 노드가 존재한다면 부모 노드의 번호는 floor(N/2) = (N을 2로나눈 몫)이 됩니다. 이 성질을 이용하여 부모노드를 찾아 갈 수 있습니다.
        
          반대로 노드의 번호가 N이고 자식노드가 존재한다면 자식 노드의 번호는 2N + 1, 2N + 2 가 됩니다.
      - 이진트리의 종류
        - 포화 이진 트리(Full Binary Tree)
        - 모든 레벨에 노드가 포화상태로 차 있는 트리.
        - 완전 이진 트리(Complete Binary Tree)
        - 포화 이진 트리의 노드 번호 1번부터  n번까지 빈 자리가 없는 이진 트리
        - 편향 이진 트리(Skewed Binary Tree)
        - 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만 가진 이진 트리
    
    <br>
    
    - 표현
    
      - 배열을 이용한 이진트리의 표현
    
        ![1570679769038](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1570679769038.png)
    
        - 배열을 이용한 표현의 단점은 공간을 비효율적으로 사용할 수 있다는 것에 있습니다.
    
          ![1570679852357](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1570679852357.png)
    
          다음과 같이 편향이진 트리일 때 공간 효율은 매우 낮게 나타납니다. 뿐만 아니라 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의 크기 변경이 어렵기 때문에 비효율적 입니다.
    
      - 연결 리스트를 이용한 이진트리의 표현
    
          ![1570679998083](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1570679998083.png)
    
      - 순회(traversal)
    
        - 전위 순회(preorder traversal) : VLR
          - 자손 노드보다 현재 노드를 먼저 방문
            - 현재노드 방문 -> V
            - 현재노드의 왼쪽 서브트리를 순회 -> L
            - 현재노드의 오른쪽 서브 트리를 순회 -> R
        - 중위 순회(inorder traversal) : LVR
          - 왼쪽 자손노드, 현재 노드, 오른쪽 자손 노드 순으로 방문
            - 현재노드의 왼쪽 서브트리를 순회 -> L
            - 현재노드 방문 -> V
            - 현재노드의 오른쪽 서브 트리를 순회 -> R
      - 후위 순회(postorder traversal) : LRV
          - 현재 노드보다 자손 노드를 먼저 방문
          - 현재노드의 왼쪽 서브트리를 순회 -> L
            - 현재노드의 오른쪽 서브 트리를 순회 -> R
          - 현재노드 방문 -> V
    
    - 수식트리
    
      - 수식을 표현하는 이진 트리
    
    - 이진 탐색 트리
    
      ![1570683900965](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1570683900965.png)
    
      자료구조의 기본은 삽입, 삭제 입니다.
    
      이진 탐색트리의 **삽입 연산**은 간단합니다. 삽입하고 싶은 데이터의 위치를 찾기 위해 탐색 연산을 합니다. 탐색 연산을 하면서 노드를 타고 타고 가다가 탐색이 실패한 지점에 값을 삽입합니다. 그림으로 보면 아래와 같습니다.
    
      ![1570684536983](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1570684536983.png)
    
      이진 탐색 트리의 **삭제 연산**은 리프 노드(leaf node)를 삭제하는 경우와 루트 노드(root node)를 삭제하는 경우로 나누어 집니다.
    
      리프 노드를 삭제하는 경우는 리프 노드의 자식노드들을 부모노드에게 입양시켜주면 끝입니다.(연결시켜주면 끝)
    
        루트 노드를 삭제하는 경우는 루트역할을 할 노드를 찾아 줍니다. 이 때 루트역할을 할 노드는 루트노드의 왼쪽자식노드중에 가장 큰 녀석 혹은 오른쪽자식노드중에 가장 작은 녀석을 루트 노드로 끄집어 올립니다.

      - 힙트리

        - 힙 트리는 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해 만든 자료구조 입니다.
      - 힙은 키 값이 가장 큰 노드를 찾기 위한 최대 힙(max heap)과 키 값이 가장 작은 노드를 찾기 위한 최소 힙(min heap)이 있습니다.
    
  - 허프만트리
    
  - 트라이
    
  - ST, SA
    
  - 균형 이진 탐색 트리(AVL), B 다진트리, 2-3-4 트리
    
    - 세그먼트트리
    
      - 인덱스트리
    
    - 아호코라식트리

- 개념

  - 비선형구조
  - 원소들 간에 1:n 관계를 가지는 자료구조

- 정의

  - 노드 중 최상위 노드를 루트노드(root)라고 합니다. 루트노드는 더이상 부모 노드가 없는 것을 뜻합니다.
  - 트리는 부 트리(subtree)로 구성되어 있습니다.
  - 트리의 가장 작은 단위는 노드입니다. 노드는 트리의 원소를 뜻하며 이 때, 가장 끝에 있는 노드를 단말노드(leaf node)라고 합니다.
  - 간선(edge)은 노드를 연결하는 선입니다. 부모 노드와 자식 노드를 연결합니다.
  - 형제노드(sibling node)는 같은 부모 노드의 자식노드들을 뜻합니다.
  - 조상노드는 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들을 말합니다.
  - 서브트리(subtree) 부모노드와 연결된 간선을 끊었을 때 생성되는 트리를 말합니다.
  - 차수(degree)는 어떤 노드에 연결된 간선(또는 자식노드)의 수를 차수라고 합니다. 차수가 0인 노드를 단말 노드(leaf node)라고 합니다.
  - 노드의 높이는 루트노드에서 노드에 이르는 간선의 수를 말하며 노드의 레벨이라고도 합니다.





### 균형 이진 탐색 트리(AVL)

balance factor를 관리함  balance factor = lefth - righth 

balance 가 맞지 않는 녀석은 끄집어 올림 



### 허프만 트리



### 트라이(Trie)

문자들의 트리를 만들어 놓은거이 트라이 입니다.

- compresed tries
- suffix trie
  - 모든 suffix에 대한 compresed tries 
  - 자료구조가 너무 무거워서 suffix array로 대신함
    - suffix array 는 LCP(longest common prefix)를 쥐고 있음 





K 개의 단어로 이루어진 사전이 있다. 각 단어의 길이는 최대 m이라고 하자. 주어진 문자열 T에서 이 사전에 나오는 단어가 나온 경우를 모두 찾으려면 어떻게 하면 될까?

- kmp를 k번 돌린다??? 
  - 너무 느린데? 문자열을 한번만 읽고 모든 답을 찾을 수 는 없나?

이 문제를 해결하는 트리가 **아호코라식 트리(Aho-Corasick Tree)** 

아호코라식 알고리즘은 KMP 알고리즘과 거의 흡사합니다. 하나의 차이점이





### 세그먼트 트리(인터벌 트리, 구간트리)

- 데이터가 단말에만 있고 중간 노드들은 자기 구간에서 데이터들의 메타정보를 쥐고 있는 트리입니다.

#### 인덱스 트리

- 포화 이진 트리

#### 펜윅 트리

#### range minimum query(RMQ)

