## PL(Program Language)

PL의 type 시스템이 무엇인가?

Program 제어라는 것이 무엇인가?

	- 순차구조 (ex. x = 10; x = 20 일때 x의 값이 순차적으로 변하는 것)
	- 선택구조 (ex. if문에 의해 로직이 분기가 되는 것)
	- 반복구조 (ex. for, while 같은 반복구조)
	- 이 3개의 구조로 모든 알고리즘을 작성할 수 있따.



IM 등급이라는 것은 위의 두개를 아느냐? 이것을 물어보는것 = 1차배열 2차배열을 이용해 현실의 문제를 알고리즘으로 만들 수 있느냐?

Ad 등급 : 완전검색을 할줄 아니?

Pro : 어떤 패턴이 반복될 때 이것을 자료구조화 할 수 있는가? 최적화, 



P : 인간이 견딜 수 있는 시간에 해결할 수 있는 문제

NP : 인간이 견딜 수 없는 시간에 해결할 수 없는 문제 -> 근사 알고리즘으로 풀거나, 인공지능으로 해결 이때 자료구조는 트리자료구조

## 자료구조(Data Structure)

- ADT(Abstract Data Type) : 추상 자료형

1. 자료

2. 연산 (자료구조의 논리적인 모습을 해치지 않으면서 연산이 일어나야 한다.)
   - 삽입
   - 삭제
   - 순회

실제 Product에서 쓰이는 자료구조와 검정을 할 떄 쓰는 자료구조를 선택해서 사용할줄 알아야 함. 자료구조 별로 성능이 확연히 다름.



### 01. 자료구조의 종류

1. 선형

   - 배열 : 인덱스로 개별 인자에 접근 가능한 자료구조, 비어있어도 됨
     - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
     - 기초수준의 배열 활용 문제 : Gravity Problem (교재, 16p), Baby-gin Game(교재 19p)
   - 리스트 : 비어있으면 안됨. 삽입 삭제가 빈번하게 일어나는 자료를 처리할 때는 리스트를 쓰는게 좋음.
   - 스택 : 하나씩 자료를 쌓아간다. 후입 선출
   - 큐 : 줄서는것과 비슷 선입 선출

2. 비선형

   - 비선형 자료들은 직관적으로 알기 쉽지않음 어떤 방식으로 표현되는지 알고있어야 함.

   - 트리 : 사이클이 없는 무방향 그래프를 트리라고 함, 트리는 그래프의 부분집합
     - 이진트리
     - 이진 탐색트리
     - AVL
     - B
     - 트라이
     - 하프만트리
     - 아호코라식 트리
     - 세그먼트 트리
     - 
   - 그래프 : 인접 행렬, 인접 리스트로 표현함
     - 순회(traversal) : 비선형 구조의 자료들을 중복없이 빠짐없이 조회 하는 것.
       - DFS(Depth First Search) : 깊이 우선 탐색, 스택
       - BFS() :가까운것 우선 탐색, 큐



## 알고리즘

알고리즘

	- 유한한 **단계**를 통해 문제를 해결하기 위한 **절차**나 방법 

무엇이 좋은 알고리즘인가?

- **정확성** : 얼마나 정확하게 동작하는가?, 최우선!!! 무조건 돌아가는게 짱임
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가?
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가, 시험에서는 메모리가 널널함
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지 없이 최적화되었는가

알고리즘의 성능

- 시간복잡도(Time Complexity) 
  - 작업량을 표현 실제 걸리는 시간을 측정, 실행되는 명령문의 개수를 계산한다. 
  - 빅-오(O)표기법
    - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
    - 계수(Coefficient)는 생략
    - O(3n+2) = O(3n) = O(n)
    - 입력값을 몇번 접근하느냐.

1. 검색

   - 완전검색(**Brute-force** or **Generate-and-test**) : 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다. 
- 순열(TSP문제 : O(n!))
     - 조합
- 부분집합(배낭문제 : O(2**n))
     - 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
- 모든 경우의 수를 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾을 확률이 높음.
     - 완전검색으로 해답을 찾고 성능 개선을 위해 다른 알고리즘을 사용해 보는 것이 좋음.
- 순차 검색(Sequential search)
     - O(n) : 어쨋든 다 돌아봐야 되니까 시간복잡도가 n에 디펜드함.
  - 정렬 되어있는 배열의 순차검색은 값을 비교할 수 있기 때문에 검색실패시 cost를 줄일 수 있음.
   - 보간검색
- 이진검색(Binary search)
     - 이진검색하려면 일단 정렬이 되어있어야함.
     - 소주뚜껑 게임이랑 똑같음.
     - 재귀로도 짤 수 있다.

**알고리즘을 설계했다면 검증은 필수!!!! 전역해를 도출할 수 있는가!!!**

## 정렬	

정렬 상태에 따라서 검색 속도가 매우 차이남. 

- O(n**2) : 버블정렬, 삽입정렬, 선택정렬

- O(nlogn) : 퀵정렬, 병합(머지)정렬, 힙정렬
- O(n+k) : 카운팅정렬(리스트요소의 범위가 있어야함, n:리스트의 길이, k: 정수의 최대값)



#### 

- 선택정렬
  -  최소값을 찾아서 맨 앞과 교환
  - 맨처음위치를 제외하고 같은 과정 반복

## 설계기법

- 그리드 : 탐욕 알고리즘 설계기법, 검증이 반드시 필요함
- 분할 정복(divide conquer) : 중요하지만 이것만을 이용해서 풀 수있는 문제는 없음
- 백트래킹(Back Tracking) : 상태 공간트리를 DFS로 돌리는 것. 즉, 스택을 이용하던지 재귀를 이용해서
- DP
  - 재귀적 DP : 
  - 반복적 DP :





## 순열(Permutation)

서로 다른 것들 중 몇 개를 뽑아 한 줄로 나열하는 것

서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.

nPr = n * (n-1) * (n-2) * ... * (n-r+1)

nPn = n!



결정과 최적해문제는 동전의 양면이다.



## 탐욕 알고리즘(greedy algorithm)

지금 현재 상황에서 가장 좋은 것을 선택하는 알고리즘.

거스름돈 줄이기 문제



```python
if __name__ == '__main__';
	if datetime.minute() >= 50;
		쉬는시간()
	else:
		계속진행()
```







beeback@hanmail.net 백경원 알고리즘 강사님 메일 

과제 제출의 마감 시간은 당일 자정까지 입니다.

메일제목 2기서울2반1월17일홍길동 형식

제출하는 파일이름은 서울2반1월17일홍길동.zip 형식입니다.

통과한 파이썬 소스만 제출해주세요

solving club에 올라온 문제에 대한 소스는 보내지 않으셔도 됩니다.

함수는 당분간 쓰지 맙시다.



감사합니다.









문제에서 제시하는대로 자료구조를 잡아서 처리하려고하는게 일단 심플하다.

Do not recompute!!! 중요한 원칙

```python
for i in range(N):
    cnt[ int(cards[i]) ] += 1
    
특정 값이 몇번 나왔는지 세는 알고리즘. 
```



edge case : 엣지 케이스



## 2차배열

1차원 list를 묶어놓은 list

- 2차 배열의 접근

  - 이중 for문을 이용한 순회 탐색

    - 행 우선순회 : outer for에서 행 inner for에서 열
    - 열 우선순회 : outer for에서 열 inner for에서 행 
    - 지그재그 순회 : outer for에서 행 inner for 에서 열을 지그재그순서로(ex. 한번은 앞에서 한번은 뒤에서~)

  - 델타를 이용한 2차 배열 탐색

    ```python
    dx = [0,0,-1,1]
    dy = [-1,1,0,0]
    my_sum = 0
    for x in range(len(my_list)):
        for y in range(len(my_list[0])):
            for k in range(4):
                temp_x = x + dx[k]
                temp_y = y + dy[k]
    ```

    

- 2차 배열의 활용

  - 전치 행렬(Tranposed)

- 부분집합 합(Subset Sum) 문제

  - 완전검색 & 바이너리 카운팅을 이용하자

  - i&(1<<j) : 2진연산으로 숫자 i가 2진수로 표현되어있을 때 j번째 비트가 무엇인지?

  - 부분집합 구하기

    ```python
    n = len(arr)
    
    for i in range(1<<n):
        for j in range(n):
            if i & (1<<j):
                print(arr[j],end=", ")
        print()
    print()
    ```





하는일이 같고 파라미터만 틀려진다?? -> 재귀로짤수있음.



## 인덱스

record의 집합을 table ,  table의 집합을 relational database



## 선택 알고리즘(Selection Algorithm)

저장되어 있는 자료로 부터 k번째로 크거나 작은 원소를 찾는 방법.

- 선택 과정
  1. 정렬
  2. 원소가져오기
- 다른 선택과정
  1. k번째 원소 도달하기 전까지 min을 이용해서 k까지만 정렬시키고 찾아냄 O(kn)



## DP(Dynamic Programing)

재귀 할 때 함수호출 시간을 최소화하기위해 메모를 같이함



## 문자열(String of characters)

- 문자열(string)은 문자(character)들의 배열이다. 
- ASCII(American Standard Code for Information Interchange)
- 각각의 문자는 다국적 코드체계, 유니코드체계로 bit열 형태로 저장되어 있다
  - 웹에서 주로쓰는 유니코드 인코딩 포맷은 UTF-8(Unicode Transformation Format)
  - 윈도우나 자바에서는 UTF-16을, Unix에서는 UTF-32를 사용.
- Big-endian
  - 큰 값이 앞에오는 저장 방식, 그대로 저장.
- Little-endian
  - 작은 값이 앞에오는 저장 방식, 역순으로 저장.  두개 다 하이레벨 프로그래밍 수준에서는 알필요도 없고 크게 의미도 없음. 

- 파이썬에서는 문자형 자료가 없고 모두 문자열로 처리함 문자가 1개여도 문자열임. 그리고 iterable 타입이므로 슬라이싱도 할 수 있음.
  - 단점은 내용물을 고칠 수 없음(Immutable)
- i to a : 숫자 to 문자, a to i : 문자 to 숫자





### 문자열의 분류

- fixed length
- variable length
  - length controlled (Java 언어에서 문자열)
    - class 안에 문자열의 정보를 접근할 수 있는 객
  - delimited (c 언어에서 문자열)
    - 어디까지가 문자인지 표시하는 null character(or delimeter)를 프로그래머가 직접 짜야댐







### 패턴매칭

- 고지식한 알고리즘(Brute Force로 풀기)   >> O(MN)
  - 처음부터 끝까지 순회하면서 패턴내의 문자를 일일이 비교하기.
- 카프-라빈 알고리즘
- KMP 알고리즘 >> O(M+N)
- 보이어-무어 알고리즘 
  - 가장 많이쓰임, 많은 프로그램에서 검색알고리즘으로 사용됨



## 스택

물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조.

마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(Last In First Out, LIFO)

- 스택에서 마지막 삽입된 원소의 위치를 top이라고 한다.
- overflow
  -  꽉찼는데 더 넣을라고함
- underflow
  -  없는데 더 뺄라고함



### DP(Dynamic Programming), 동적 계획

최적화 문제를 해결하는 알고리즘 설계기법임. 동적 계획 알고리즘은 먼저 입력 크기가 작은 부분의 문제들을 모두 해결한 후 그 해들을 이용하여 보다 큰 부분의 문제를 해결하고 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘임. 

- 점화식 찾으면 끝남 근데 점화식 찾기가 어려움
- DP는 완전검색을 스마트하게 하는 것임.

DP에는 재귀적 DP, 반복적 DP 가 있고 각각 장단점이 있음.

- 재귀적 DP(Recursive DP)
  - 재귀 함수에서 이미 호출한 함수의 함수값을 저장하는 방식으로 구현
  - 반복적 DP에 비해 구현하기 쉬움(Top-down 방식으로 문제를 볼 수 있기 때문)
  - 배열을 무조건 다 안채워도
- 반복적 DP(Iterative DP)
  - 일반적으로 재귀적 DP에 비해 속도가 빠름



### DP알고리즘 연습하기





### DFS(Depth First Search), 깊이 우선탐색

비선형 그래프, 비선형 트리,

트리 : 사이클이 없는 무방향 그래프

### BFS(Breadth First Search), 너비 우선 탐색





