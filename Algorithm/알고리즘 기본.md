## PL(Program Language)

PL의 type 시스템이 무엇인가?

Program 제어라는 것이 무엇인가?

	- 순차구조 (ex. x = 10; x = 20 일때 x의 값이 순차적으로 변하는 것)
	- 선택구조 (ex. if문에 의해 로직이 분기가 되는 것)
	- 반복구조 (ex. for, while 같은 반복구조)
	- 이 3개의 구조로 모든 알고리즘을 작성할 수 있따.



IM 등급이라는 것은 위의 두개를 아느냐? 이것을 물어보는것 = 1차배열 2차배열을 이용해 현실의 문제를 알고리즘으로 만들 수 있느냐?

Ad 등급 : 완전검색을 할줄 아니?

P : 인간이 견딜 수 있는 시간에 해결할 수 있는 문제

NP : 인간이 견딜 수 없는 시간에 해결할 수 없는 문제 -> 근사 알고리즘으로 풀거나, 인공지능으로 해결 이때 자료구조는 트리자료구조

## 자료구조(Data Structure)

- ADT(Abstract Data Type) : 추상 자료형

1. 자료

2. 연산 (자료구조의 논리적인 모습을 해치지 않으면서 연산이 일어나야 한다.)
   - 삽입
   - 삭제
   - 순회

실제 Product에서 쓰이는 자료구조와 검정을 할 떄 쓰는 자료구조를 선택해서 사용할줄 알아야 함. 자료구조 별로 성능이 확연히 다름.



### 01. 자료구조의 종류

1. 선형

   - 배열 : 인덱스로 개별 인자에 접근 가능한 자료구조, 비어있어도 됨
     - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
     - 기초수준의 배열 활용 문제 : Gravity Problem (교재, 16p), Baby-gin Game(교재 19p)
   - 리스트 : 비어있으면 안됨. 삽입 삭제가 빈번하게 일어나는 자료를 처리할 때는 리스트를 쓰는게 좋음.
   - 스택 : 하나씩 자료를 쌓아간다. 후입 선출
   - 큐 : 줄서는것과 비슷 선입 선출

2. 비선형

   - 비선형 자료들은 직관적으로 알기 쉽지않음 어떤 방식으로 표현되는지 알고있어야 함.

   - 트리 : 사이클이 없는 무방향 그래프를 트리라고 함, 트리는 그래프의 부분집합
     - 이진트리
     - 이진 탐색트리
     - AVL
     - B
     - 트라이
     - 하프만트리
     - 아호코라식 트리
     - 세그먼트 트리
     - 
   - 그래프 : 인접 행렬, 인접 리스트로 표현함
     - 순회(traversal) : 비선형 구조의 자료들을 중복없이 빠짐없이 조회 하는 것.
       - DFS(Depth First Search) : 깊이 우선 탐색, 스택
       - BFS() :가까운것 우선 탐색, 큐



## 알고리즘

알고리즘

	- 유한한 **단계**를 통해 문제를 해결하기 위한 **절차**나 방법 

무엇이 좋은 알고리즘인가?

- **정확성** : 얼마나 정확하게 동작하는가?, 최우선!!! 무조건 돌아가는게 짱임
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가?
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가, 시험에서는 메모리가 널널함
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지 없이 최적화되었는가

알고리즘의 성능

- 시간복잡도(Time Complexity) 
  - 작업량을 표현 실제 걸리는 시간을 측정, 실행되는 명령문의 개수를 계산한다. 
  - 빅-오(O)표기법
    - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
    - 계수(Coefficient)는 생략
    - O(3n+2) = O(3n) = O(n)
    - 입력값을 몇번 접근하느냐.

1. 검색

   - 완전검색(**Brute-force** or **Generate-and-test**) : 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다. 

     - 순열(TSP문제 : O(n!))

     - 조합

     - 부분집합(배낭문제 : O(2**n))

     - 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.

     - 모든 경우의 수를 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾을 확률이 높음.

     - 완전검색으로 해답을 찾고 성능 개선을 위해 다른 알고리즘을 사용해 보는 것이 좋음.
     
       

**알고리즘을 설계했다면 검증은 필수!!!! 전역해를 도출할 수 있는가!!!**

## 정렬	

정렬 상태에 따라서 검색 속도가 매우 차이남. 

- O(n**2) : 버블정렬, 삽입정렬, 선택정렬

- O(nlogn) : 퀵정렬, 병합(머지)정렬, 힙정렬
- O(n+k) : 카운팅정렬(리스트요소의 범위가 있어야함, n:리스트의 길이, k: 정수의 최대값)



#### 



## 설계기법

- 그리드 : 탐욕 알고리즘 설계기법, 검증이 반드시 필요함
- 분할 정복(divide conquer) : 중요하지만 이것만을 이용해서 풀 수있는 문제는 없음
- 백트래킹(Back Tracking) : 상태 공간트리를 DFS로 돌리는 것. 즉, 스택을 이용하던지 재귀를 이용해서
- DP
  - 재귀적 DP : 
  - 반복적 DP :





## 순열(Permutation)

서로 다른 것들 중 몇 개를 뽑아 한 줄로 나열하는 것

서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.

nPr = n * (n-1) * (n-2) * ... * (n-r+1)

nPn = n!



결정과 최적해문제는 동전의 양면이다.



## 탐욕 알고리즘

거스름돈 줄이기 문제



```python
if __name__ == '__main__';
	if 강의시간 >= 50;
		쉬는시간()
	else:
		강의시간 += 1
		계속진행()
		
```







beeback@hanmail.net 백경원 알고리즘 강사님 메일 

과제 제출의 마감 시간은 당일 자정까지 입니다.

메일제목 2기서울2반1월17일홍길동 형식

제출하는 파일이름은 서울2반1월17일홍길동.zip 형식입니다.

통과한 파이썬 소스만 제출해주세요

solving club에 올라온 문제에 대한 소스는 보내지 않으셔도 됩니다.

함수는 당분간 쓰지 맙시다.



감사합니다.