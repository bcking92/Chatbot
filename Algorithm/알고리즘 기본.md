## PL(Program Language)

PL의 type 시스템이 무엇인가?

Program 제어라는 것이 무엇인가?

	- 순차구조 (ex. x = 10; x = 20 일때 x의 값이 순차적으로 변하는 것)
	- 선택구조 (ex. if문에 의해 로직이 분기가 되는 것)
	- 반복구조 (ex. for, while 같은 반복구조)
	- 이 3개의 구조로 모든 알고리즘을 작성할 수 있따.



IM 등급이라는 것은 위의 두개를 아느냐? 이것을 물어보는것 = 1차배열 2차배열을 이용해 현실의 문제를 알고리즘으로 만들 수 있느냐?

Ad 등급 : 완전검색을 할줄 아니?

Pro : 어떤 패턴이 반복될 때 이것을 자료구조화 할 수 있는가? 최적화, 



P : 인간이 견딜 수 있는 시간에 해결할 수 있는 문제

NP : 인간이 견딜 수 없는 시간에 해결할 수 없는 문제 -> 근사 알고리즘으로 풀거나, 인공지능으로 해결 이때 자료구조는 트리자료구조

## 자료구조(Data Structure)

- ADT(Abstract Data Type) : 추상 자료형

1. 자료

2. 연산 (자료구조의 논리적인 모습을 해치지 않으면서 연산이 일어나야 한다.)
   - 삽입
   - 삭제
   - 순회

실제 Product에서 쓰이는 자료구조와 검정을 할 때 쓰는 자료구조를 선택해서 사용할줄 알아야 함. 자료구조 별로 성능이 확연히 다름.



### 01. 자료구조의 종류

1. 선형

   - 배열 : 인덱스로 개별 인자에 접근 가능한 자료구조, 비어있어도 됨
     - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
     - 기초수준의 배열 활용 문제 : Gravity Problem (교재, 16p), Baby-gin Game(교재 19p)
   - 리스트 : 비어있으면 안됨. 삽입 삭제가 빈번하게 일어나는 자료를 처리할 때는 리스트를 쓰는게 좋음.
   - 스택 : 하나씩 자료를 쌓아간다. 후입 선출
   - 큐 : 줄서는것과 비슷 선입 선출

2. 비선형

   - 비선형 자료들은 직관적으로 알기 쉽지않음 어떤 방식으로 표현되는지 알고있어야 함.

   - 트리 : 사이클이 없는 무방향 그래프를 트리라고 함, 트리는 그래프의 부분집합
     - 이진트리
     - 이진 탐색트리
     - AVL
     - B
     - 트라이
     - 하프만트리
     - 아호코라식 트리
     - 세그먼트 트리
     - 
   - 그래프 : 인접 행렬, 인접 리스트로 표현함
     - 순회(traversal) : 비선형 구조의 자료들을 중복없이 빠짐없이 조회 하는 것.
       - DFS(Depth First Search) : 깊이 우선 탐색, 스택이용함
       - BFS(Breadth First Search) : 가까운것 우선 탐색, 큐이용함



## 알고리즘

알고리즘

- 유한한 **단계**를 통해 문제를 해결하기 위한 **절차**나 방법 

무엇이 좋은 알고리즘인가?

- **정확성** : 얼마나 정확하게 동작하는가?, 최우선!!! 무조건 돌아가는게 짱임
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가?
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가, 시험에서는 메모리가 널널함
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지 없이 최적화되었는가

알고리즘의 성능

- 시간복잡도(Time Complexity) 
  - 작업량을 표현 실제 걸리는 시간을 측정, 실행되는 명령문의 개수를 계산한다. 
  - 빅-오(O)표기법
    - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
    - 계수(Coefficient)는 생략
    - O(3n+2) = O(3n) = O(n)
    - 입력값을 몇번 접근하느냐.

1. 검색

   - 완전검색(**Brute-force** or **Generate-and-test**) : 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다. 
- 순열(TSP문제 : O(n!))
     - 조합
- 부분집합(배낭문제 : O(2**n))
     - 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
- 모든 경우의 수를 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾을 확률이 높음.
     - 완전검색으로 해답을 찾고 성능 개선을 위해 다른 알고리즘을 사용해 보는 것이 좋음.
- 순차 검색(Sequential search)
     - O(n) : 어쨋든 다 돌아봐야 되니까 시간복잡도가 n에 디펜드함.
  - 정렬 되어있는 배열의 순차검색은 값을 비교할 수 있기 때문에 검색실패시 cost를 줄일 수 있음.
   - 보간검색
- 이진검색(Binary search)
     - 이진검색하려면 일단 정렬이 되어있어야함.
     - 소주뚜껑 술게임이랑 똑같음.
     - 재귀로도 짤 수 있다.

**알고리즘을 설계했다면 검증은 필수!!!! 전역해를 도출할 수 있는가!!!**



## 정렬	

정렬 상태에 따라서 검색 속도가 매우 차이남. 

- O(n**2) : 버블정렬, 삽입정렬, 선택정렬

- O(nlogn) : 퀵정렬, 병합(머지)정렬, 힙정렬
- O(n+k) : 카운팅정렬(리스트요소의 범위가 있어야함, n:리스트의 길이, k: 정수의 최대값)



#### 

- 선택정렬
  -  최소값을 찾아서 맨 앞과 교환
  - 맨처음위치를 제외하고 같은 과정 반복

## 설계기법

- 그리드 : 탐욕 알고리즘 설계기법, 검증이 반드시 필요함
- 분할 정복(divide conquer) : 중요하지만 이것만을 이용해서 풀 수있는 문제는 없음
- 백트래킹(Back Tracking) : 상태 공간트리를 DFS로 돌리는 것. 즉, 스택을 이용하던지 재귀를 이용해서
- DP
  - 재귀적 DP : 
  - 반복적 DP :





## 순열(Permutation)

서로 다른 것들 중 몇 개를 뽑아 한 줄로 나열하는 것

서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.

nPr = n * (n-1) * (n-2) * ... * (n-r+1)

nPn = n!



결정과 최적해문제는 동전의 양면이다.



## 탐욕 알고리즘(greedy algorithm)

지금 현재 상황에서 가장 좋은 것을 선택하는 알고리즘.

거스름돈 줄이기 문제



```python
if __name__ == '__main__';
	if datetime.minute() >= 50;
		쉬는시간()
	else:
		계속진행()
```







beeback@hanmail.net 백경원 알고리즘 강사님 메일 

과제 제출의 마감 시간은 당일 자정까지 입니다.

메일제목 2기서울2반1월17일홍길동 형식

제출하는 파일이름은 서울2반1월17일홍길동.zip 형식입니다.

통과한 파이썬 소스만 제출해주세요

solving club에 올라온 문제에 대한 소스는 보내지 않으셔도 됩니다.

함수는 당분간 쓰지 맙시다.



감사합니다.









문제에서 제시하는대로 자료구조를 잡아서 처리하려고하는게 일단 심플하다.

Do not recompute!!! 중요한 원칙

```python
for i in range(N):
    cnt[ int(cards[i]) ] += 1
    
특정 값이 몇번 나왔는지 세는 알고리즘. 
```



edge case : 엣지 케이스



## 2차배열

1차원 list를 묶어놓은 list

- 2차 배열의 접근

  - 이중 for문을 이용한 순회 탐색

    - 행 우선순회 : outer for에서 행 inner for에서 열
    - 열 우선순회 : outer for에서 열 inner for에서 행 
    - 지그재그 순회 : outer for에서 행 inner for 에서 열을 지그재그순서로(ex. 한번은 앞에서 한번은 뒤에서~)

  - 델타를 이용한 2차 배열 탐색

    ```python
    dx = [0,0,-1,1]
    dy = [-1,1,0,0]
    my_sum = 0
    for x in range(len(my_list)):
        for y in range(len(my_list[0])):
            for k in range(4):
                temp_x = x + dx[k]
                temp_y = y + dy[k]
    ```

    

- 2차 배열의 활용

  - 전치 행렬(Tranposed)

- 부분집합 합(Subset Sum) 문제

  - 완전검색 & 바이너리 카운팅을 이용하자

  - i&(1<<j) : 2진연산으로 숫자 i가 2진수로 표현되어있을 때 j번째 비트가 무엇인지?

  - 부분집합 구하기

    ```python
    n = len(arr)
    
    for i in range(1<<n):
        for j in range(n):
            if i & (1<<j):
                print(arr[j],end=", ")
        print()
    print()
    ```





하는일이 같고 파라미터만 틀려진다?? -> 재귀로짤수있음.



## 인덱스

record의 집합을 table ,  table의 집합을 relational database



## 선택 알고리즘(Selection Algorithm)

저장되어 있는 자료로 부터 k번째로 크거나 작은 원소를 찾는 방법.

- 선택 과정
  1. 정렬
  2. 원소가져오기
- 다른 선택과정
  1. k번째 원소 도달하기 전까지 min을 이용해서 k까지만 정렬시키고 찾아냄 O(kn)



## DP(Dynamic Programing)

재귀 할 때 함수호출 시간을 최소화하기위해 메모를 같이함.



## 문자열(String of characters)

- 문자열(string)은 문자(character)들의 배열이다. 
- ASCII(American Standard Code for Information Interchange)
- 각각의 문자는 다국적 코드체계, 유니코드체계로 bit열 형태로 저장되어 있다
  - 웹에서 주로쓰는 유니코드 인코딩 포맷은 UTF-8(Unicode Transformation Format)
  - 윈도우나 자바에서는 UTF-16을, Unix에서는 UTF-32를 사용.
- Big-endian
  - 큰 값이 앞에오는 저장 방식, 그대로 저장.
- Little-endian
  - 작은 값이 앞에오는 저장 방식, 역순으로 저장.  두개 다, 하이레벨 프로그래밍 수준에서는 알필요도 없고 크게 의미도 없음. 

- 파이썬에서는 문자형 자료가 없고 모두 문자열로 처리함 문자가 1개여도 문자열임. 그리고 iterable 타입이므로 슬라이싱도 할 수 있음.
  - 단점은 내용물을 고칠 수 없음(Immutable)
- i to a : 숫자 to 문자, a to i : 문자 to 숫자





### 문자열의 분류

- fixed length
- variable length
  - length controlled (Java 언어에서 문자열)
    - class 안에 문자열의 정보를 접근할 수 있는 객체
  - delimited (c 언어에서 문자열)
    - 어디까지가 문자인지 표시하는 null character(or delimeter)를 프로그래머가 직접 정해줘야댐..







### 패턴매칭

- 고지식한 알고리즘(Brute Force로 풀기)   >> O(MN)
  - 처음부터 끝까지 순회하면서 패턴내의 문자를 일일이 비교하기.
- 카프-라빈 알고리즘
- KMP 알고리즘 >> O(M+N)
- 보이어-무어 알고리즘 
  - 가장 많이쓰임, 많은 프로그램에서 검색알고리즘으로 사용됨



## 스택

물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조.

마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(Last In First Out, LIFO)

- 스택에서 마지막 삽입된 원소의 위치를 top이라고 한다.
- overflow
  -  꽉찼는데 더 넣을라고함
- underflow
  -  없는데 더 뺄라고함



### DP(Dynamic Programming), 동적 계획

최적화 문제를 해결하는 알고리즘 설계기법임. 동적 계획 알고리즘은 먼저 입력 크기가 작은 부분의 문제들을 모두 해결한 후 그 해들을 이용하여 보다 큰 부분의 문제를 해결하고 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘임. 

- 점화식 찾으면 끝남 근데 점화식 찾기가 어려움
- DP는 완전검색을 스마트하게 하는 것임.

DP에는 재귀적 DP, 반복적 DP 가 있고 각각 장단점이 있음.

- 재귀적 DP(Recursive DP)
  - 재귀 함수에서 이미 호출한 함수의 함수값을 저장하는 방식으로 구현
  - 반복적 DP에 비해 구현하기 쉬움(Top-down 방식으로 문제를 볼 수 있기 때문)
  - 배열을 무조건 다 안채워도
- 반복적 DP(Iterative DP)
  - 일반적으로 재귀적 DP에 비해 속도가 빠름



### DP알고리즘 연습하기





### DFS(Depth First Search), 깊이 우선탐색

비선형 그래프, 비선형 트리,

트리 : 사이클이 없는 무방향 그래프

<<<<<<< HEAD
- DFS를 이용한 Combination,( 합이 10인 부분집합 구하기 )

  ```python
  num_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  
  subset = []
  
  memoization = [0 for i in range(11)]
  
  def dfs(arr, x, k):
      # 끝까지 다 가봤으면 합이 10일 때 담음
      if x == k:
          temp = []
          for i in range(10):
              if memoization[i+1] == 1:
                  temp.append(num_list[i])
          if sum(temp) == 10:
              subset.append(temp)
     # 아니면 x번째 원소를 선택하거나 아니거나~
      else:
          x += 1
          memoization[x] = 1
          dfs(arr, x, k)
          memoization[x] = 0
          dfs(arr, x, k)
  
  dfs(num_list, 0, 10)
  print(subset)
  ```



- DFS를 이용한 Permutation

  ```python
  # 조합이랑 비슷한데 약간다르게~ 방문했는지 확인하는 리스트를 하나 만들어줌
  num_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  
  subset = []
  
  memoization = [0 for i in range(11)]
  
  visited = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  
  def dfs(arr, x, k):
      if x == k:
          temp = []
          for i in range(10):
              if memoization[i+1]:
                  temp.append(memoization[i+1])
          subset.append(temp)
      else:
          x += 1
          for i in range(10):
              if not visited[i]:
                  memoization[x] = num_list[i]
                  visited[i] = 1 # 방문했을땐 체크
                  dfs(arr, x, k)
                  visited[i] = 0 # 뒤돌아갈땐 빼주기
  
  dfs(num_list, 0, 3)
  print(subset)
  ```

  

=======
### 


>>>>>>> a01963a1f8e41fcf1c5c28e932e13a9a620b72c3

### 계산기

- 토큰(Token) : 프로그래밍에서는 의미가 있는 가장 작은단위를 토큰이라고함
- 연산자 : +, -, *, / 같은것. 항이 몇개 필요한지에 따라 이항연산자, 삼항연산자등이 있음.
- 피연산자 : 연산을 당하는 데이터
- 중위표기법을 후위표기법으로 변경해보자
  - 

### 백트래킹(Backtracking)

- 막히면 되돌아가서 다시 해를 찾는 기법
- 최적화문제와 결정문제를 해결할 수 있다.
  - 결정문제 : 문제의 조건을 만족하는 해가 존재하는지 여부를 'yes' or 'no'로 답하는 문제
    - 미로 찾기
    - n-Queen
    - Map coloring
    - 부분 집합의 합 등

- 백트래킹의 동작방식은 DFS임. DFS에서 가지치기(Pruning)을 하게 되면 백트래킹이 되는것.
- 가지치기(Pruning)
  - 어떤 노드의 유망성을 점검한 후에 유망한지(Promising) 아닌지 판단하고 유망하지 않으면 그 노드의 부모노드로 되돌아가서(backtracking) 다음 자식노드로 이동함.
  - 어떤 노드를 방문했을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않음. 반대로 해답의 가능성이 있으면 유망하다고 봄.
  - 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않음!
- 백트래킹 알고리즘의 순서
  1. 상태 공간 트리의 깊이 우선 검색을 실시
  2. 각 노드가 유망한지 점검
  3. 노드가 유망하지 않으면 노드의 부모 노드로 돌아가서 검색을 계속함
- 최악의 경우 여전히 시간복잡도는 지수적이므로 한계가 있긴 함 -> AI나, 근사알고리즘을 이용



조합 탐색, 완전 이진 트리



### 분할 정복 알고리즘

- 설계 전략
  - 분할(Divide) : 해결할 문제를 여러 개의 작은 부분으로 나눈다.
  - 정복(Conquer) : 나눈 작은 문제를 각각 해결한다.
  - 통합(Combine) : (필요하다면) 해결된 해답을 모은다.
- 문제에 따라 통합까지 해야되는 것도 있고 아닌 것도 있음.

- 예제)

  - 거듭 제곱

    ```python
    def Power(Base, Exponent):
        if Exponent == 0 or Base == 0:
            return 1
        
        if Exponent % 2 == 0:
            NewBase = Power(Base, Exponent/2)
    		return NewBase * NewBase
        else:
            NewBase = Power(Base, (Exponent-1)/1)
            return (NewBase * NewBase) * Base
    ```

  - 퀵 정렬

    - 퀵 정렬의 원리

      우선 정렬할 수열 덩어리의 가운데에 점을 찍고 이 지점을 Pivot, 즉 P라고 한다. 수열의 가장 왼쪽 인덱스(첫 인덱스)를 L이라고 하고 가장 오른쪽 인덱스(마지막 인덱스)를 R이라고 하자. L위치에 있는 수가 P위치의 수보다 크면 L은 그 위치에 고정시키고 작다면 L을 오른쪽으로 한칸 옮긴다(L = L + 1).   R 위치에 있는 수가 P위치의 수보다 작거나 같으면 그 위치에 고정하고 크다면 R은 왼쪽으로 이동한다(R = R - 1).  이러다 보면 크게 2가지의 경우가 나온다.

       1. L = R 이 되는 경우

          - 이 경우에는 Pivot 위치에 있던 수와 L=R 위치에 있던 수를 교환하고 L=R 위치에 있는 수의 최종 위치를 확정시킨다.

            왜냐하면 L과 R이 만났다는 것은 L의 왼쪽에는 모두 P보다 작거나 같은 수가 있고 R의 오른쪽에는 모두 P보다 큰 수가 있다는 것이기 때문이다. 그러므로 양쪽의 수들이 정렬되어있는 것과 별개로 L=R의 위치에 있는 수를 고정 시킬 수 있는 것이다.

      	2.  L < R 이 되는 경우

          - 이 경우에는 L위치에 있는 수가 R 위치에 있는 수보다 큰 경우이다. 왼쪽의 수가 피벗보다 크고 오른쪽의 수가 피벗보다 작으므로 두 수의 위치를 바꾸면 기존의 L과 R의 위치에서 계속해서 알고리즘을 진행할 수 있다. 이 과정을 반복하다가 L = R이 되는 경우 또 한 요소의 위치를 확정할 수 있다.

      

      이렇게 반복하는 과정에서 수열이 두 파트로 나누어지게 된다. 그럼 두개로 나누어진 수열을 각각 다시 같은 방법으로 정렬한다.

    ```python
    def quickSort(a, begin, end):
        # 시작점인덱스가 끝점인덱스보다 작을때, 즉, 정렬할 배열이 존재할 때!
        # 끝점이 시작점보다 크면 배열이 없는 것임. ex) 시작점 2 끝점 1
        if begin < end:
            # partition 함수를 통해 고정된 지점 p를 가져온다.
            p = partition(a, begin, end)
            quickSort(a, begin, p-1)
            quickSort(a, p+1, end)
            
    def partition(a, begin, end):
        # pivot 지점은 시작점과 끝점의 중앙으로 한다.
        pivot = (begin + end)//2
        # L은 시작점의 인덱스로 한다.
        L = begin
        # R은 끝점의 인덱스로 한다.
        R = end
        # L과 R이 만나지 않을 경우 아래 과정을 계속 반복한다.
        while L < R:
            # L에 있는 값이 피벗 값보다 크거나 같을 때 까지 L을 오른쪽으로 이동시킴
            while(a[L] < a[pivot] and L < R ):
                L += 1
            # R에 있는 값이 피벗 값보다 작을때 까지 R을 왼쪽으로 이동시킴
            while(a[R] >= a[pivot] and L < R):
                R -= 1
            # L과 R이 같은가 한번 보고
            if L < R:
                # 같지 않다면 L위치가 피벗위치랑 같은지 본다.
                if L == pivot:
                    # L위치가 피벗의 위치와 같다는 것은 피벗의 왼쪽에 있는 수는 모두 피벗보다
                    # 작다는것을 의미함. 그러므로 현재 피벗위치에 있는 숫자는 최소한 지금위치와 				# 같거나 더 오른쪽에 있을 것임.
                    # 그런데 R의 위치보다 오른쪽에 있는 수들은 모두 피벗보다
                    # 큰 수들이므로 그 수들은 비교할 필요가 없음, 게다가 R위치에 있던 수는
                    # 피벗위치에 있던 수보다 작거나 같음. 그런데 pivot과 L의 위치가 같으면
                    # pivot = R = L 일때 무한루프가 생기므로 pivot을 R위치로 옮겨주고 계속
                    # 반복함.
                    pivot = R
                a[L], a[R] = a[R], a[L]
        # 만약 L = R 이 되서 루프를 빠져나오면 pivot 위치에 있던 수를 L = R 위치에 있던 자리로 
        # 확정시키고 그 자리를 return함.
        a[pivot], a[R] = a[R], a[pivot]
        return R
    ```

    

### BFS(Breadth First Search), 너비 우선 탐색
큐를이용함. 뎁스가 얕은 노드부터 다 들리고 그다음 뎁스로 넘어가는 방식으로 검색함. 

